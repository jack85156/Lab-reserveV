-- -----------------------------------------------------------------------------
-- Supabase scheduled cleanup for expired reservations
--
-- How to use:
--   1. Open Supabase Dashboard â†’ SQL Editor.
--   2. Paste this entire script and run it once.
--   3. A pg_cron job named "cleanup-expired-reservations" will run every 4 hours.
--
-- The job removes rows from public.bookings whose end time (Central Time Zone, United States)
-- has already passed. A lightweight log table captures each run.
-- Note: 'America/Chicago' automatically handles CST (UTC-6) and CDT (UTC-5) transitions.
-- -----------------------------------------------------------------------------

-- Ensure pg_cron is available (already enabled in Supabase projects by default)
create extension if not exists pg_cron;

-- Optional: keep a history of cleanup runs for audit/debugging
create table if not exists public.reservation_cleanup_log (
    id bigint generated by default as identity primary key,
    deleted_count integer not null,
    ran_at timestamptz not null default now(),
    -- Optional arrays to summarize what was deleted in this run
    instrument_names text[],
    reservation_names text[],
    reservation_dates date[],
    start_times text[],
    end_times text[]
);

-- Table to log details of deleted reservations
create table if not exists public.reservation_cleanup_details (
    id bigint generated by default as identity primary key,
    cleanup_log_id bigint references public.reservation_cleanup_log(id) on delete cascade,
    reservation_name text,
    instrument_name text,
    reservation_date date,
    start_time text,
    end_time text,
    deleted_at timestamptz not null default now()
);

-- Enable Row Level Security on log tables
alter table public.reservation_cleanup_log enable row level security;
alter table public.reservation_cleanup_details enable row level security;

-- Create policies for log tables (allow public access, similar to bookings table)
create policy "Public Access" 
on public.reservation_cleanup_log 
for all 
using (true) 
with check (true);

create policy "Public Access" 
on public.reservation_cleanup_details 
for all 
using (true) 
with check (true);

-- Ensure the bookings table exists (if not, create it with proper structure)
-- Note: This assumes your bookings table already exists. If not, create it first.
-- The cleanup function uses SECURITY DEFINER to bypass RLS policies.

-- Dedicated function that removes expired reservations and records the count and details.
-- Using SECURITY DEFINER to run with the privileges of the function owner (bypasses RLS)
create or replace function public.cleanup_expired_reservations()
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
    deleted_count integer := 0;
    current_central_time timestamptz;
    cleanup_log_id bigint;
    v_instrument_names text[];
    v_reservation_names text[];
    v_reservation_dates date[];
    v_start_times text[];
    v_end_times text[];
begin
    -- Get current time in Central Time Zone (United States)
    -- 'America/Chicago' handles both CST (UTC-6) and CDT (UTC-5) automatically
    current_central_time := timezone('America/Chicago', now());
    
    -- Create temporary table to store details of reservations to be deleted
    create temp table if not exists temp_expired_reservations (
        reservation_name text,
        instrument_name text,
        reservation_date date,
        start_time text,
        end_time text
    ) on commit drop;
    
    -- First, capture details of expired reservations into temp table
    insert into temp_expired_reservations (
        reservation_name,
        instrument_name,
        reservation_date,
        start_time,
        end_time
    )
    select 
        user_name,              -- Updated: from bookings.user_name
        instrument,             -- Updated: from bookings.instrument
        date::date,             -- Updated: bookings.date is text -> cast to date
        start_time,             -- Updated: from bookings.start_time
        end_time                -- Updated: from bookings.end_time
    from public.bookings
    where
        -- Only delete if date and end_time exist
        date is not null 
        and end_time is not null
        and end_time <> ''
        -- Construct the reservation end timestamp in Central Time Zone (United States)
        and timezone(
                'America/Chicago',
                (date || ' ' || end_time)::timestamp without time zone
            ) < current_central_time;
    
    -- Get count of expired reservations
    select count(*) into deleted_count from temp_expired_reservations;
    
    -- Delete expired reservations from bookings table
    delete from public.bookings
    where
        date is not null 
        and end_time is not null
        and end_time <> ''
        and timezone(
                'America/Chicago',
                (date || ' ' || end_time)::timestamp without time zone
            ) < current_central_time;

    -- Log the cleanup run if any reservations were deleted
    if deleted_count > 0 then
        -- Aggregate details into arrays for the log table
        select
            array_agg(distinct instrument_name),
            array_agg(reservation_name),
            array_agg(reservation_date),
            array_agg(start_time),
            array_agg(end_time)
        into
            v_instrument_names,
            v_reservation_names,
            v_reservation_dates,
            v_start_times,
            v_end_times
        from temp_expired_reservations;

        -- Insert into cleanup log and get the ID
        insert into public.reservation_cleanup_log (
            deleted_count,
            instrument_names,
            reservation_names,
            reservation_dates,
            start_times,
            end_times
        )
        values (
            deleted_count,
            v_instrument_names,
            v_reservation_names,
            v_reservation_dates,
            v_start_times,
            v_end_times
        )
        returning id into cleanup_log_id;
        
        -- Insert details of deleted reservations from temp table
        insert into public.reservation_cleanup_details (
            cleanup_log_id,
            reservation_name,
            instrument_name,
            reservation_date,
            start_time,
            end_time
        )
        select 
            cleanup_log_id,
            reservation_name,
            instrument_name,
            reservation_date,
            start_time,
            end_time
        from temp_expired_reservations;
        
        -- Clean up temp table
        drop table if exists temp_expired_reservations;
    end if;
end;
$$;

-- Remove any previously scheduled job with the same name so we don't duplicate it.
select cron.unschedule(jobid)
from cron.job
where jobname = 'cleanup-expired-reservations';

-- Schedule the cleanup to run every 4 hours.
select cron.schedule(
    'cleanup-expired-reservations',
    '0 */4 * * *',
    $$select public.cleanup_expired_reservations();$$
);

-- Set function owner to postgres (has full permissions)
alter function public.cleanup_expired_reservations() owner to postgres;

-- Optional: run immediately so you don't wait for the first cron tick.
select public.cleanup_expired_reservations();

-- -----------------------------------------------------------------------------
-- TROUBLESHOOTING: If cleanup function cannot access bookings table
-- -----------------------------------------------------------------------------
-- If you get "permission denied" or "relation does not exist" errors:
--
-- 1. Check if RLS is enabled on bookings table:
--    SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public' AND tablename = 'bookings';
--
-- 2. If RLS is enabled and causing issues, you can temporarily disable it for testing:
--    ALTER TABLE public.bookings DISABLE ROW LEVEL SECURITY;
--    (Re-enable with: ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;)
--
-- 3. Verify the bookings table exists and has the correct columns:
--    SELECT column_name, data_type FROM information_schema.columns 
--    WHERE table_schema = 'public' AND table_name = 'bookings';
--
-- 4. Check function permissions:
--    SELECT proname, proowner, prosecdef FROM pg_proc WHERE proname = 'cleanup_expired_reservations';
--
-- 5. Test the function manually:
--    SELECT public.cleanup_expired_reservations();
-- -----------------------------------------------------------------------------



