-- -----------------------------------------------------------------------------
-- Supabase scheduled cleanup for expired reservations
--
-- How to use:
--   1. Open Supabase Dashboard â†’ SQL Editor.
--   2. Paste this entire script and run it once.
--   3. A pg_cron job named "cleanup-expired-reservations" will run every 4 hours.
--
-- The job removes rows from public.bookings whose end time (Central Time Zone, United States)
-- has already passed. A lightweight log table captures each run.
-- Note: 'America/Chicago' automatically handles CST (UTC-6) and CDT (UTC-5) transitions.
-- -----------------------------------------------------------------------------

-- Ensure pg_cron is available (already enabled in Supabase projects by default)
create extension if not exists pg_cron;

-- Optional: keep a history of cleanup runs for audit/debugging
create table if not exists public.reservation_cleanup_log (
    id bigint generated by default as identity primary key,
    deleted_count integer not null,
    ran_at timestamptz not null default now()
);

-- Table to log details of deleted reservations
create table if not exists public.reservation_cleanup_details (
    id bigint generated by default as identity primary key,
    cleanup_log_id bigint references public.reservation_cleanup_log(id) on delete cascade,
    reservation_name text,
    instrument_name text,
    reservation_date date,
    start_time text,
    end_time text,
    deleted_at timestamptz not null default now()
);

-- Ensure the bookings table exists (if not, create it with proper structure)
-- Note: This assumes your bookings table already exists. If not, create it first.
-- The cleanup function uses SECURITY DEFINER to bypass RLS policies.

-- Dedicated function that removes expired reservations and records the count and details.
-- Using SECURITY DEFINER to run with the privileges of the function owner (bypasses RLS)
create or replace function public.cleanup_expired_reservations()
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
    deleted_count integer := 0;
    current_central_time timestamptz;
    cleanup_log_id bigint;
begin
    -- Get current time in Central Time Zone (United States)
    -- 'America/Chicago' handles both CST (UTC-6) and CDT (UTC-5) automatically
    current_central_time := timezone('America/Chicago', now());
    
    -- Create temporary table to store details of reservations to be deleted
    create temp table if not exists temp_expired_reservations (
        reservation_name text,
        instrument_name text,
        reservation_date date,
        start_time text,
        end_time text
    ) on commit drop;
    
    -- First, capture details of expired reservations into temp table
    insert into temp_expired_reservations (
        reservation_name,
        instrument_name,
        reservation_date,
        start_time,
        end_time
    )
    select 
        "name",
        "instrument",
        "date"::date,  -- Cast text to date
        "startTime",
        "endTime"
    from public.bookings
    where
        -- Only delete if date and endTime exist
        "date" is not null 
        and "endTime" is not null
        and "endTime" != ''
        -- Construct the reservation end timestamp in Central Time Zone (United States)
        and (
            -- Parse date + endTime as Central Time Zone timestamp
            -- First create a timestamp without timezone, then convert to Central Time (America/Chicago)
            -- This ensures proper handling of CST/CDT transitions
            (
                timezone(
                    'America/Chicago',
                    ("date" || ' ' || "endTime")::timestamp without time zone
                )
            ) < current_central_time
        );
    
    -- Get count of expired reservations
    select count(*) into deleted_count from temp_expired_reservations;
    
    -- Delete expired reservations from bookings table
    delete from public.bookings
    where
        "date" is not null 
        and "endTime" is not null
        and "endTime" != ''
        and (
            (
                timezone(
                    'America/Chicago',
                    ("date" || ' ' || "endTime")::timestamp without time zone
                )
            ) < current_central_time
        );

    -- Log the cleanup run if any reservations were deleted
    if deleted_count > 0 then
        -- Insert into cleanup log and get the ID
        insert into public.reservation_cleanup_log (deleted_count)
        values (deleted_count)
        returning id into cleanup_log_id;
        
        -- Insert details of deleted reservations from temp table
        insert into public.reservation_cleanup_details (
            cleanup_log_id,
            reservation_name,
            instrument_name,
            reservation_date,
            start_time,
            end_time
        )
        select 
            cleanup_log_id,
            reservation_name,
            instrument_name,
            reservation_date,
            start_time,
            end_time
        from temp_expired_reservations;
        
        -- Clean up temp table
        drop table if exists temp_expired_reservations;
    end if;
end;
$$;

-- Remove any previously scheduled job with the same name so we don't duplicate it.
select cron.unschedule(jobid)
from cron.job
where jobname = 'cleanup-expired-reservations';

-- Schedule the cleanup to run every 4 hours.
select cron.schedule(
    'cleanup-expired-reservations',
    '0 */4 * * *',
    $$select public.cleanup_expired_reservations();$$
);

-- Set function owner to postgres (has full permissions)
alter function public.cleanup_expired_reservations() owner to postgres;

-- Optional: run immediately so you don't wait for the first cron tick.
select public.cleanup_expired_reservations();

-- -----------------------------------------------------------------------------
-- TROUBLESHOOTING: If cleanup function cannot access bookings table
-- -----------------------------------------------------------------------------
-- If you get "permission denied" or "relation does not exist" errors:
--
-- 1. Check if RLS is enabled on bookings table:
--    SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public' AND tablename = 'bookings';
--
-- 2. If RLS is enabled and causing issues, you can temporarily disable it for testing:
--    ALTER TABLE public.bookings DISABLE ROW LEVEL SECURITY;
--    (Re-enable with: ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;)
--
-- 3. Verify the bookings table exists and has the correct columns:
--    SELECT column_name, data_type FROM information_schema.columns 
--    WHERE table_schema = 'public' AND table_name = 'bookings';
--
-- 4. Check function permissions:
--    SELECT proname, proowner, prosecdef FROM pg_proc WHERE proname = 'cleanup_expired_reservations';
--
-- 5. Test the function manually:
--    SELECT public.cleanup_expired_reservations();
-- -----------------------------------------------------------------------------



